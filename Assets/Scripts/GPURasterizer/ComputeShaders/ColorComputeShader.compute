#pragma kernel CSMain
#pragma kernel VertexTransform

float4x4 MATRIX_M;
float4x4 MATRIX_VP;
static float4x4 MATRIX_MVP = mul(MATRIX_VP, MATRIX_M);

struct Vertex
{
    float3 position;
    float2 uv;
    float3 normal;
    float4 tangent;
    float4 color;
};
struct VertexOutput
{
    float4 positionCS;
    float4 positionOS;
    float4 normalWS;
    float4 tangent;
    float2 uv;
    float4 color;
    float3 viewDir;
};

RWTexture2D<float4> ResultTexture;

StructuredBuffer<Vertex> VertexBuffer;
RWStructuredBuffer<VertexOutput> VertexOutputBuffer;


float3 ObjectToWorldNormal(float3 normal)
{
    return normalize(mul(normal, (float3x3)MATRIX_M));
}

[numthreads(128, 1, 1)]
void VertexTransform(uint3 id : SV_DispatchThreadID)
{

    Vertex data = VertexBuffer[id.x];
    VertexOutputBuffer[id.x].positionCS = mul(MATRIX_MVP, float4(data.position, 1));
    VertexOutputBuffer[id.x].positionOS = data.position;
    VertexOutputBuffer[id.x].normalWS = ObjectToWorldNormal(data.normal);
    VertexOutputBuffer[id.x].tangent = data.tangent;
    VertexOutputBuffer[id.x].uv = data.uv;
    VertexOutputBuffer[id.x].color = data.color;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    ResultTexture.GetDimensions(width, height);
    
    float2 uv = (id.xy + 0.5) / float2(width, height);
    float4 color = float4(uv.x, uv.y, 0, 1);
    ResultTexture[id.xy] = color;
    // ResultTexture[id.xy] = 1;

}